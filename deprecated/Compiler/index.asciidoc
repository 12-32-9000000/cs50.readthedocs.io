---
tags: []
title: Compiler
---

A *compiler* is a program that transforms human-readable
link:source code[source code] into _machine code_—the raw ones and
zeroes that the CPU reads when it executes your program. The compiler
used in CS50 is the C compiler `gcc`.

The compiler executes a series of stages while converting your program
into executable form, but generally you don't need to worry about all
that: a simple command like `make myprogram` will compile a C program
called `myprogram.c`.


Detailed Description
~~~~~~~~~~~~~~~~~~~~

What `gcc` does while processing your program really consists of four
stages:

1.  The *preprocessor* pastes in link:header file[header files] that you
`#include`d, removes link:comment[comments], and replaces
link:macro[macros] with their value.
2.  The actual *compiler* transforms the program from C into
link:assembly language[assembly language], a special programming
language that (though still written in text) represents very closely
what the CPU is doing while executing a program.
3.  The *assembler* translates the assembly-language produced by the
compiler and transforms it into link:object code[object code]: raw
binary data that exactly represent the instructions executed by the CPU
while the program is running.
4.  Last, the *linker* resolves any references to functions or global
variables in the object code and links them to the appropriate
libraries. If your code somewhere contains a call to the function
`[[printf]]`, the linker makes sure that the call goes to the code for
`printf` in the system's C library.

Fortunately, you don't need to worry about each of those steps; `gcc`
will take care of that for you. When you invoke `gcc` on the
link:command line[command line] like `gcc myprogram.c`, it will generate
an executable version of your program in a file called `a.out`.

But it gets even better. You'll often want to give `gcc` some additional
options to specify the way in which to compile your code, for example to
help debugging, to warn you about possible problems, and to optimize
your code. And it gets boring having all your programs called `a.out`.
So that you don't need to remember all those arguments every time you
compile your code, there is a tool called `[[make]]` to remember the
long-form commands for you. In the CS50 appliance, I can simply type
`make myprogram` and it'll automatically create an executable called
`myprogram`.


Compiler options
^^^^^^^^^^^^^^^^

When I type `make myprogram`, `make` actually executes the following
command for me:
`gcc -ggdb -std=c99 -Wall -Werror    myprogram.c  -lcrypt -lcs50 -lm -o myprogram`.

* `-ggdb` tells the compiler to include debugging information with the
program, so that debugging your program with `[[gdb]]` becomes easier.
* `-std=c99` sets the version of the C language used in the program to
http://en.wikipedia.org/wiki/C99[C99], which was accepted as an
international standard in 1999.
* `-Wall -Werror` makes `gcc` emit warnings on all kinds of possible
issues it finds in your code and treat the warnings as if they were
errors. Those warnings may be annoying, but they help you write better
C.
* `-lcrypt -lcs50 -lm` is a series of directives to the linker, which
tell it to link the compiled program to these three pre-compiled
libraries. Without them, you wouldn't be able to use functions like
`GetInt` in your program.
* `-o myprogram` makes the compiler output the executable program in a
file called `myprogram`, instead of the default `a.out`.

Another option that you may find useful is `-O`, which tells the
compiler to optimize the generated code, so that it (hopefully) runs
faster. There are different values for this option, ranging from `-O0`
(no optimization) to `-O3` (much optimization).

To find out about additional options (warning: there's a lot), type
`gcc --help` or `man gcc`.


Things that can go wrong
^^^^^^^^^^^^^^^^^^^^^^^^

As you learn C, you'll often find `gcc` complaining about various faults
in your code. Often, `gcc` will give you a whole cascade of cryptically
worded errors—but fixing only the first syntax error will go a long way
towards making all those errors disappear. Even if you don't understand
the wording of the error, it's worthwhile to find the line the compiler
is yelling about and looking whether you can find a problem.


Examples
~~~~~~~~


Compiling a program and troubleshooting
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

I wrote a simple program to check whether people live in the right
house. It looks like this:

------------------------------------------
/*
 * buggy.c
 *
 * Demonstrates how to use the compiler.
 */
#include <cs50.h>
#include <stdbool.h>

int main(int argc, char *argv[])
{
    printf("What house do you live in? ");
    char *house = GetString();
    if(check_house())
        printf("Good choice!\n");
    else
        printf("Wrong!\n");
    return 0;
}

bool check_house(char *in)
{
    if(strcmp(in, "Mather House") == 0)
        return true;
}
------------------------------------------

But when I try to compile it with `make buggy`, I get a whole list of
errors:

-----------------------------------------------------------------------------------------------------------
gcc -ggdb -std=c99 -Wall -Werror    buggy.c  -lcrypt -lcs50 -lm -o buggy
buggy.c: In function 'main':
buggy.c:11:5: error: implicit declaration of function 'printf' [-Werror=implicit-function-declaration]
buggy.c:11:5: error: incompatible implicit declaration of built-in function 'printf' [-Werror]
buggy.c:13:5: error: implicit declaration of function 'check_house' [-Werror=implicit-function-declaration]
buggy.c:12:11: error: unused variable 'house' [-Werror=unused-variable]
buggy.c: At top level:
buggy.c:19:6: error: conflicting types for 'check_house'
buggy.c:13:8: note: previous implicit declaration of 'check_house' was here
buggy.c: In function 'check_house':
buggy.c:21:5: error: implicit declaration of function 'strcmp' [-Werror=implicit-function-declaration]
buggy.c:23:1: error: control reaches end of non-void function [-Werror=return-type]
cc1: all warnings being treated as errors

make: *** [buggy] Error 1
-----------------------------------------------------------------------------------------------------------

Well, we'll have to fix those. The ones on lines 11, 13, and 21, about
those implicit declarations, indicate that we forgot some prototypes and
header inclusions. `printf` is from `stdio.h`, and `strcmp` is from
`string.h`, so I'll add those. The errors on lines 12 and 19 alert me to
the fact that I forgot to give `house` as the argument to the
`check_house` function. Last, the error on line 23 tells me that I
forgot to make `check_house` return `false` if the string doesn't match.

With all that fixed, the program looks like this:

------------------------------------------
/*
 * buggy.c
 *
 * Demonstrates how to use the compiler.
 */
#include <cs50.h>
#include <stdbool.h>
#include <stdio.h>
#include <string.h>

bool check_house(char *in);

int main(int argc, char *argv[])
{
    printf("What house do you live in? ");
    char *house = GetString();
    if(check_house(house))
        printf("Good choice!\n");
    else
        printf("Wrong!\n");
    return 0;
}

bool check_house(char *in)
{
    if(strcmp(in, "Mather House") == 0)
        return true;
    else
        return false;
}
------------------------------------------

This compiles without errors.


Compiling a simple program step by step
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

We'll follow what happens while we compile this very simple C program:

-------------------------------------------------
/*
 * simple.c
 *
 * A simple program to show how a compiler works.
 */
#define RETURNVALUE 42
int main(int argc, char *argv[])
{
    return RETURNVALUE;
}
-------------------------------------------------

When I invoke the preprocessor with `gcc -E simple.c`, I get:

--------------------------------
# 1 "simple.c"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "simple.c"






int main(int argc, char *argv[])
{
    return 42;
}
--------------------------------

The comment has disappeared, the constant has been replaced with its
value, and the preprocessor has added some notes to help the compiler.

Now I invoke the compiler (but not the assembler and linker) with
`gcc -S simple.c` and get the following in `simple.s`:

---------------------------------------------------------
    .file   "simple.c"
    .text
    .globl  main
    .type   main, @function
main:
.LFB0:
    .cfi_startproc
    pushl   %ebp
    .cfi_def_cfa_offset 8
    .cfi_offset 5, -8
    movl    %esp, %ebp
    .cfi_def_cfa_register 5
    movl    $42, %eax
    popl    %ebp
    .cfi_def_cfa 4, 4
    .cfi_restore 5
    ret
    .cfi_endproc
.LFE0:
    .size   main, .-main
    .ident  "GCC: (GNU) 4.6.1 20110908 (Red Hat 4.6.1-9)"
    .section    .note.GNU-stack,"",@progbits
---------------------------------------------------------

Well, that looks complicated. In CS50, you don't need to read assembly;
if you continue into more advanced CS classes, being able to read
assembly may come in handy when you want to understand in more detail
what your program is doing.

Now we invoke the assembler with `gcc -c simple.s` and get the object
code in `simple.o`. That's raw binary data, so I'm not going to show it
in full here, but it contains the following code (in hexadecimal) that
corresponds to our original `main` function: `5589 e5b8 2a00 0000 5dc3`.
Now, that's even worse than assembly.

But we still don't have an executable program. For that, we need one
more step: linking. To do that, I simply write `gcc simple.o`, which
produces a file called `a.out`. This file is similar to `simple.o`, but
contains a bit more boilerplate binary code needed to make a real
executable program.

Now, when I execute the program with `./a.out` and check its exit code
with `echo $?`, I see that it worked: it returned 42!

Category:Glossary
