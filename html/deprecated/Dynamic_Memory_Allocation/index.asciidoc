---
tags: []
title: Dynamic Memory Allocation
---

*Dynamic memory allocation* is the allocation of memory on the heap
instead of the stack. This allows you to store data across different
function calls. If you instead put your data into a
link:local variable[local variable], it will no longer be accessible
once the function returns. In C, you can request dynamic memory using
the *malloc* library function. After you allocate memory, you always
have to return it to the operating system using the *free* function.


Detailed Description
~~~~~~~~~~~~~~~~~~~~

The basic C interface for dynamic memory allocation isn't complicated:
you call the function `void *malloc(int size)` with the number of bytes
that you want allocated as the argument, and `malloc` returns a pointer
to the memory for you. If `malloc` is unable to allocate sufficient
memory, it returns `NULL`; you should always check the return value
after you call `malloc`. When you're done using the memory pointed to by
`ptr`, you use `void free(void *ptr)` to return the memory. This
function doesn't return anything.

However, there are some complications. `malloc` and `free` aren't very
friendly when you do something that's not allowed, like writing beyond
the bounds of the `malloc`ed memory, `free`ing memory that you've
already `free`d, or accessing `malloc`ed memory after you already
`free`d it. Exactly what happens in such cases is undetermined; it may
crash immediately (the best outcome!), it may silently output the wrong
data, or it may work perfectly until you decide to upgrade your C
library and the bug is suddenly exposed. By default, the CS50 Appliance
uses a special `malloc` implementation that warns you about some of
these issues, but it cannot find everything, so it doesn't excuse you
from thinking carefully about the correctness of your code.

Another problem is that of _memory leaks_—failing to `free` memory after
you're done using it. Memory leaks may hurt performance, both of the
program itself and of the system as a whole, since the program holds on
to memory that it no longer needs and the operating system is unable to
grant this memory to other programs. Therefore, you should always `free`
any memory that you `malloc`ed. (Analogously, you should `fclose` any
file that you `fopen`.) A tool that can help you find memory leaks and
similar issues is Valgrind.


Other dynamic memory allocation functions
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

In addition to `malloc` and `free`, the C standard library provides two
more functions for dynamic memory allocation:

* `calloc` is similar to `malloc`, but (unlike `malloc`) it fills the
newly allocated memory with zeroes, and it takes two arguments instead
of one: the number of objects for which memory should be allocated and
the size of each object. Thus, you could rewrite
`int *ptr = malloc(10 * sizeof(int));` as
`int *ptr = calloc(10, sizeof(int));` if you want the allocated memory
to be zeroed.
* `realloc` re-allocates a block of memory that has been previously
`malloc`ed (or `calloc`ed) to a differently sized block. It takes as
arguments the pointer to the old block and the desired new size of the
block, copies over memory from the old to the new block, and returns a
pointer to the new block. Like `malloc`, `realloc` will return `NULL` if
it fails; thus, you should be careful with code like
`char *ptr = malloc(10 * sizeof(char)); ptr = realloc(ptr, 12 * sizeof(char));`—if
`realloc` fails, `ptr` is `NULL` and you have no way to `free` the
previously `malloc`ed memory.


Examples
~~~~~~~~


Using dynamic memory allocation
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The following program calls a function that returns a string, and then
prints that string. Or does it?

-------------------------------------------------------
/*
 * local.c
 *
 * Illustrates the problems with using local variables.
 */
#include <stdio.h>
#include <string.h>

char *GetString(void);

int main(void)
{
    char *str = GetString();
    printf("%s\n", str);
    return 0;
}

char *GetString(void)
{
    char out[5];
    strcpy(out, "CS50");
    return out;
}
-------------------------------------------------------

Well, in fact it doesn't even compile when I type `make local`. Stupid
`make` for treating warnings as errors. With simply
`gcc local.c -o local` it does compile (with a warning, but who cares
about warnings?). Now, when I run the program with `./local`, it doesn't
actually print anything except for the newline. The reason for that is
that `out` is a local variable of the `GetString()` function, so after
that function returns it is no longer legal to look at the contents of
the local variable. But that's exactly what the program is doing. Such a
program is said to exhibit _undefined behavior_ in C, which means that
the compiler is free to do whatever it feels like.

To avoid that, you can use `malloc` instead:

------------------------------------------------------------------
/*
 * dynamic.c
 *
 * Illustrates the use of malloc() to dynamically allocate memory.
 */
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

char *GetString(void);

int main(void)
{
    char *str = GetString();
    printf("%s\n", str);
    free(str);
    return 0;
}

char *GetString(void)
{
    char *out = malloc(5);
    if(out == NULL)
        exit(1);
    strcpy(out, "CS50");
    return out;
}
------------------------------------------------------------------

Here, `GetString()` allocates memory for its output string using
`malloc()`. Now `gcc` produces no warnings and the program prints the
correct output. However, the program also illustrates a few common
gotchas with dynamic memory allocation. First, you should always check
the return value of `malloc()`—sometimes it is unable to allocate
memory, and returns `NULL`. This program immediately exits in that case.
Second, all memory that has been dynamically allocated also needs to be
freed again using a call to `free()`, as is done here in `main()`.


Some pitfalls
^^^^^^^^^^^^^

The following program illustrates a number of possible problems with
dynamically allocated memory:

------------------------------------------------------------------------------
/*
 * problems.c
 *
 * Illustrate common bugs with dynamic memory allocation
 */
#include <stdio.h>
#include <stdlib.h>

void set_first(int *in) 
{
    in[0] = 42;
    return;
}

void set_fifth(int *in) 
{
    in[4] = 9001;
    return;
}

void set_all(int *in, int count) 
{
    for(int i = 0; i < count; i++)
    {
        in[i] = i;
    }
    return;
}

int main(void)
{
    int *ptr1 = malloc(4 * sizeof(int));
    int *ptr2 = malloc(10 * sizeof(int));

    set_all(ptr1, 4);
    set_all(ptr2, 9); // tenth element not set

    set_fifth(ptr1); // out of bounds access

    for(int i = 0; i < 10; i++)
    {
        printf("%d ", ptr1[i]); // will access out of bounds memory if i > 4
        printf("%d\n", ptr2[i]); // will access uninitialized memory if i == 9
    }
    free(ptr2);

    set_first(ptr2); // illegal, we already freed ptr2

    free(ptr2); // illegal, we already freed ptr2

    return 0; // oops, ptr1 never freed
}
------------------------------------------------------------------------------

The program compiles fine, but when I run it, I get:

--------------------------------------------------------------------------
0 0
1 1
2 2
3 3
9001 4
49 5
0 6
1 7
2 8
3 0
*** glibc detected *** ./problems: free(): invalid pointer: 0x08a34020 ***
Segmentation fault (core dumped)
--------------------------------------------------------------------------

Oops, a segfault. Well, I probably shouldn't be `free`ing that pointer
twice, so let's remove the second call. When I do that, the program runs
normally: problem solved? Not so fast. Running Valgrind with
`valgrind --leak-check=full ./problems` reveals the rest of the
problems: out-of-bounds reads and writes, use of uninitialized memory,
and failure to free some memory.

Category:Glossary
