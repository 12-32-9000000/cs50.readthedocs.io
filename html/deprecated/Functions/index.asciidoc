---
tags: []
title: Functions
---

Functions in the C programming language help you to partition your code
into manageable pieces. A function is like a black box with a set of
inputs and a single output. The rest of the program does not need to
know what goes on inside the function, but the program can call the
function, provide it with the inputs, and then use the output. In this
sense, a C function performs much like a mathematical function on your
calculator. If you wanted to find the sine of x you could use the sin
function (found in math.h) without worrying about how it actually finds
the sine. `
double
sin_times_cos(double x, double y)
{
    return sin(x) * cos(y);
}
` Such a function is used for the value it computes and returns.

But functions can also be useful for the _side effects_ they cause. For
example, you might write a function called `print_instructions()`, which
has no return value, but executes a series of `printf()` statements.
`printf()` itself is a function that is executed for its side effect.
The main reasons for using functions in programming are:

* Organization. Having good functional decomposition in a piece of code
is like having a good outline for a paper.

Functions help to break up a complicated problem into more manageable
subparts, and they also help to make sure that concepts flow logically
into one another.

* Simplification. Smaller components are easier to design, easier to
implement, and far easier to debug. Good use of functions makes code
easier to read and problems easier to isolate.
* Reusability. Functions only need to be written once, and then can be
used as many times as necessary, so you can avoid duplication of code.
For instance, to ask the user a yes/no question several times throughout
a program, you might write a helper function called `ask_yes_no()` to
handle the dialog.


The Anatomy of Functions
------------------------

The shape of a C function should look familiar to you by now, because
every complete C program has at least one function, `main()`. Here’s a
little function named `accumulate_interest` taking two numbers, which
might be a bank balance and an interest rate, and producing another
number, an updated balance after interest has accrued.

[source,c]
------------------------------------------------
double
accumulate_interest(double balance, double rate)
{
    double accrued;
    double updated;

    accrued = balance * rate;
    updated = balance + accrued;

    return updated;
}
------------------------------------------------

This function definition has the following structure: (, ,...) \{...}

A function definition has a header and a body. The header always
contains these parts: 1. Return type: The type of value that a call of
the function will produce. In our example, it is double. Knowing the
return type of accumulate interest allows the compiler to know for
example, that the variable declaration double val =
accumulate_interest(bal, rate); has a valid initializer. 2. Function
name: The name that is used in the program to call this function. In
this example, the name is accumulate interest. 3. Parameter list: The
parameters, also called the function’s arguments, tell the compiler what
types of values to expect when the function is called. In our example,
the list (double balance, double rate) tells the compiler to expect two
arguments, both of type double. The parameter list can be empty, which
means that the function doesn’t expect any arguments. 2 The body of a
function definition is a sequence of declarations and statements wrapped
in braces (\{...}). When the function is called, the body is executed to
produce the function’s side effects and ultimately to return its value
(if it has one). The variables declared in a function’s body (such as
accrued and updated in accumulate interest above) are local to the
function. Assignments to those variables have no effect on variables
declared outside of the function, even if they happen to have the same
names. The variables we have been declaring in main() are actually local
variables One or more of the statements in a function body can be return
statements. A return statement ends the execution of the function and
passes the return value back to the function that called it (the
“caller”). In our example function, the return statement returns the
value updated to the caller of accumulate interest. The fact that a
return statement terminates the function immediate can be a useful way
to escape from nested loops and conditional statements without having to
exit each of them individually. If a function returns a value, then it
must have at least one return statement. (It could have more than one,
returning different values under different conditions.) If the function
doesn’t return a value, then the return statement is optional. The
function will return after it executes the last statement in its body.
Or it might contain a return that has no value expression, which returns
control to the calling function without passing a value. A function that
doesn’t return a value must have the special return type void. A
function body doesn’t have to be as verbose as the one for accumulate
interest above. An equivalent definition of can be written with just one
statement: double accumulate_interest(double balance, double rate) \{
return balance + (balance * rate); } A function definition gives all the
information that the compiler needs about a function. It describes both
how the function should be used and how its body should be translated
into machine language that the computer can execute. But just as we
sometimes need to separate the declaration of a variable from its
initialization and its uses, we sometimes want to be able to declare a
function without giving its full definition. A function declaration is
the header part of the corresponding function definition, followed by a
semicolon. For example, here is the declaration of our example function
accumulate interest: double accumulate_interest(double balance, double
rate);
