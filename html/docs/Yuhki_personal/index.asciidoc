---
tags: []
title: Yuhki_personal
---
[[]]
Network layers
~~~~~~~~~~~~~~

* Layer 5: Application
* Layer 4: Transport (TCP, UDP)
* Layer 3: Network (IP)
* Layer 2: Link (Ethernet, 802.11)
* Layer 1: Physical (cables)

TCP segment/UDP datagram/IP packet/Ethernet frame

* TCP is connection oriented: each end knows status of other end
* UDP is connection-less

[[]]
IP packet
~~~~~~~~~

* Includes TTL
* Includes header checksum, which has to change at every hop because of
TTL
* Exists throughout the journey (IP address of destination needn't
change)

[[]]
Switches and routers
~~~~~~~~~~~~~~~~~~~~

Switches are link layer (they only do Ethernet addresses) Routers are
network layer (they do IP addresses)

[[]]
Router
^^^^^^

* Two tables:
** Routing table: Converts a destination IP address to (1) IP address of
next hop (2) Output NIC
** ARP (Address Resolution Protocol) table: Convert IP address of next
hop -> MAC address of next hop

[[]]
Address Resolution Protocol
+++++++++++++++++++++++++++

* Broadcasts request for the MAC address corresponding to an IP address

[[]]
XXXX
~~~~

End-to-end principle: Network should not do anything but routing

'''''

[[]]
Link layer (Layer 2)
--------------------

* Provides:
** Error detection/correction (parity checking)
** Multiple users can access at once
** Link layer addressing
** Reliable data transfer, flow control (don't want to overflow buffer
at destination)

[[]]
Delay in packet-switched networks
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* Transmisison delay:
** R = link bandwidth (bps): how fast toll booth can transmit data
** L = packet length (bits)
** Time to send bits into link = L/R

* Propagation delay:
** d = length of physical length (how long is highway)
** s = propagation speed in medium (speed of light)
** Propagation delay = d/s

R and s are very different!

[[]]
Nodal delay
^^^^^^^^^^^

latexmath:[$d_nodal = d_proc + d_queue + d_trans + d_prop$]

* Processing delay
* Queuing delay: Make smaller queues/drop packets
* Transmission delay: Increase link speed; make packet smaller
* Propagation delay: Can't do anything about it (is speed of light)

*Round Trip Time* includes propagation delay, queuing delay, and
transmission delay.

Big pipes not necessarily good thing: creates congestion at other end.

[[]]
Queuing delay
+++++++++++++

* R = link bandwidth (bps)
* L = packet length (bits)
* a = average packet arrival rate

Traffic intensity = La/R (graph x:La/R, y:average queuing delay, graph
expo grow towards infinity at 1)

* La/R ~ 0: average queuing delay small
* La/R -> 1: delays become longer
* La/R > 1: more work arriving than can be serviced, average delay
infinite

[[]]
Ethernet frame
~~~~~~~~~~~~~~

* 7-byte preamble for sync
* 1 byte Start of Frame: 10101011
* DST MAC (6 bytes)/SRC MAC (6 bytes)/Type (2 bytes)/(Payload: e.g., IP
packet)
* Exists only on a hop-by-hop basis (obviously)
* CRC at end (4 bytes)
* Therefore, 20 bytes in total overhead
* Minimum payload size is 46 bytes

[[]]
Multiple Access Protocols
~~~~~~~~~~~~~~~~~~~~~~~~~

* Decides which nodes can transmit at what time
* Three broad classes:
** Channel Partitioning: divide channels into smaller pieces (time
slots, frequency, code)
** Random access: Allow collisions and recover from them
** Taking turns: Nodes take turns, but nodes with more to say can take
longer turns (c.f. time slot partitioning)

[[]]
Channel Partitioning
^^^^^^^^^^^^^^^^^^^^

[[]]
Time Division Multiple Access (TDMA)
++++++++++++++++++++++++++++++++++++

* Each node gets some fixed amount of time to transmit.
* Unused slots go idle
* Everyone has to have the same clock!
* Over time, everybody has an opportunity to send

[[]]
Frequency Division Multiple Access (FDMA)
+++++++++++++++++++++++++++++++++++++++++

* Divide the channel spectrum into bands
* Each station assigned fixed band
* Unused transmission time in frequency bands go idle

[[]]
Random Access
^^^^^^^^^^^^^

* Just send at full channel data rate
* Specifies:
** How to detect collisions
** How to recover from collisions (e.g., delayed retransmission)
* Examples:
** Slotted ALOHA, ALOHA, CSMA, CSMA/CD, CSMA/CA

[[]]
Slotted ALOHA
+++++++++++++

* All frames are same size
* Time is divided into equal size slots
* Nodes start to transmit only at slot beginning
* Nodes are synchronized
* If 2 or more nodes transmit in slot, all nodes detect collision
* Operation: When node obtains fresh frame, transmit in next slot
** If no collision, node can send new frame in next slot
** If collision, node retransmits frame in each subsequent slot with
probability p until success

[[]]
Pros

* Possibility for continuous transmission at full rate
* Decentralized
* Simple

[[]]
Cons

* Collisions => wasted slots
* Idle slots
* Nodes may be able to detect collision in less than time to transmit
packet
* Needs clock synchronization

[[]]
Efficiency

* Many nodes (N nodes), with many frames to send. Probability of each
transmitting in slot is p.
* Probability that given node has success in a slot: p*(1-p)^(N-1)
* Probability that any node has success in slot: Np(1-p)^(N-1)
* Maximum efficiency: find a probability q that maximizes probability of
any node having success
* Take limit of Nq(1-q)^(N-1) as N goes to infinity, gives 1/e = .37
* Therefore, at best, channels used for useful transmissions only 37% of
time!

[[]]
Pure (unslotted) ALOHA
++++++++++++++++++++++

* Don't worry about slots; just send data.
* Probability of collision doubles (since a frame can span two "slots")
* Maximum efficiency is .18 => Even worse than Slotted ALOHA

[[]]
Carrier Sense Multiple Access (CSMA)
++++++++++++++++++++++++++++++++++++

* Listen before transmit:
** If channel is idle, transmit entire frame
** If channel is busy, defer transmission

(i.e., don't interrupt others! => Just like human speech)

Collisions can still occur: *propagation delay* can mean two nodes may
not hear each other's transmission. In that case, entire transmission is
wasted.

[[]]
CSMA/CD (Collision Detection)
+++++++++++++++++++++++++++++

* Sense the carrier while sending. (easy with Ethernet, hard with
802.11)
* Transmission started in vulnerable RTT time will collide (A going one
way, B going the other way).
* If collision detected while sending:
** Abort
** Send *jam signal*: ensures other hosts don't erroneously think the
transmission succeeded
* Retransmit after random delay (Backoff - 2^n * RTT)
* Collisions are detected within a short time
* If frame transmissions time (TxT) > RTT, can detect collision and
retransmit (see diagram)
* Channel wastage is reduced because of aborts.
* Used in Ethernet 802.3

[[]]
CSMA/CA (Collision Avoidance)
+++++++++++++++++++++++++++++

* When carrier is sensed idle, sends message broadcasting intent to
send. Then waits an interval before sending.
* When sending message from A->B, where C can only be heard from B:
** A sends *Request To Send* (RTS) (source, destination, duration of
transaction)
** B replies with *Clear To Send* (CTS) - _C hears CTS too, and defers
transmission_ (avoids Hidden Terminal Problem)
* Access Point sends CTS!
* RTS _could_ collide, but is short packet.
* Data must be long enough to warrant RTS/CTS!
* Used in 802.11 because:
** Can't listen while sending
** Hidden Terminal Problem

[[]]
Taking Turns
^^^^^^^^^^^^

* Looks for best of Channel Partitioning/Random Access protocols
* *Polling method*: Master node "invites" slave nodes to transmit.
** Polling overhead, latency, single point of failure (master).
* *Token passsing method*: Control token passed from one node to next
sequentially.
** Token overhead, latency, single point of failure (token).

[[]]
Switches
~~~~~~~~

* Smarter than hubs (which just broadcast)
* Store and forward Ethernet frames
* Examine incoming frames' MAC addresses and _selectively_ forwards to
one or more ports
* Uses CSMA/CD
* Transparent (hosts don't know about them)
* Plug and play (zero configuration)
* Allows multiple simultaneous connections (no collisions); each link is
full duplex.
* Switch table
** Each entry has MAC address of host, interface to reach host, time
stamp
** Automatically learns switch table by listening to incoming packets
* When frame received:
** Is there an entry in switch table for destination?
*** Yes: Did fragment come from that segment?
**** Yes: Drop the frame
**** No: Forward to that segment
*** No: Flood to all interfaces but the one from which fragment received

