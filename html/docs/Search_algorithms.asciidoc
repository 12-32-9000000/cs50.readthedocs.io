---
tags: []
title: Search_algorithms
---
[[]]
Linear Search
-------------

Linear search is the simplest of all search algorithms. It consists of
walking through every member of the data structure of interest and
checking if each value matches the value being searched for. In the
analogy of the phonebook, a linear search for "Smith" would consist of
flipping one page at a time and checking every single name on each page
until "Smith" was found some several hundred pages later.

As its name implies, linear search runs in linear time in the worst-case
scenario (latexmath:[$O(n)$]). That is, in the worst case, the value
being searched for is the very last one of latexmath:[$n$] elements to
be checked. Of course, in the best case, the value being searched for is
the first to be checked, so linear search is in latexmath:[$\Omega(1)$].

Linear search is quite easy to implement, as the following code reveals:

code,C------------------------------------------------- code,C
int
LinearSearch(int value_to_find, int values[])
{
        int curr = 0;
        int i = 0;
        while(curr = values[i++] && curr != '\0')
        {
            if (curr == value_to_find)
            {
                return True;
            }
        }

        return False;
}
-------------------------------------------------

In this example, we're searching an array of integers, but the same
algorithm would apply for other data structures storing different data
types.

Because of its linear link:running time[running time], linear search is
a clearly suboptimal algorithm, particularly when compared to binary
search.

[[]]
Binary Search
-------------

Binary search is an algorithm which employs the divide-and-conquer
strategy. Why tackle the whole problem when you can tackle half the
problem instead?

Our first exposure to binary search was in the first lecture during
David's famous phonebook example. In order to find an entry like "Smith"
in the phonebook, we can make use of the fact that the names are sorted
in alphabetical order. We turn to the approximate middle of the phone
book, determine that "S" comes after "M" in the alphabet, tear the
phonebook in half, and throw away the half that contains all names
starting with "A" through "M." Now we take the remaining half of the
phonebook and repeat the process.

Whereas linear search in the phonebook would require flipping through
several hundred pages in order to find "Smith," binary search
accomplishes the same in a dozen or less. Each step of the algorithm
cuts the size of the original problem in half. From this, we can deduce
that the worst-case link:running time[running time] of binary search is
O(latexmath:[$\log n$]). Assuming the phonebook is about 1000 pages, for
example, it will take us less than 10 steps to find "Smith." The first
step reduces the problem to 500 pages, the second step to 250 pages, the
third step to 125 pages, and so on. Eventually, the size of the problem
is only 1 and we've found the value we were looking for.

Binary search requires that the data being search is sorted ahead of
time. The amount of time it takes to sort the data is a separate
consideration altogether.
